// SPDX-FileCopyrightText: 2021 Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0
//

/*
 * Connectivity Service Configuration
 *
 * APIs to configure connectivity service in Aether Network
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package configapi

import (
	"encoding/json"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/omec-project/webconsole/backend/logger"
	"github.com/omec-project/webconsole/configmodels"
	"github.com/omec-project/webconsole/dbadapter"
	"go.mongodb.org/mongo-driver/bson"
)

const (
	devGroupDataColl = "webconsoleData.snapshots.devGroupData"
	sliceDataColl    = "webconsoleData.snapshots.sliceData"
)

// GetDeviceGroups godoc
// @Summary      Show an account
// @Description  Returns the list of device groups
// @Tags         Device Groups
// @Accept       json
// @Produce      json
// @Router       /config/v1/device-group/ [get]
func GetDeviceGroups(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Device Groups")

	var deviceGroups []string = make([]string, 0)
	rawDeviceGroups, errGetMany := dbadapter.CommonDBClient.RestfulAPIGetMany(devGroupDataColl, bson.M{})
	if errGetMany != nil {
		logger.DbLog.Warnln(errGetMany)
	}
	for _, rawDeviceGroup := range rawDeviceGroups {
		deviceGroups = append(deviceGroups, rawDeviceGroup["group-name"].(string))
	}

	c.JSON(http.StatusOK, deviceGroups)
}

// GetDeviceGroup godoc
// @Summary      Show an account
// @Description  Returns the device group
// @Tags         Device Groups
//  @Param       deviceGroupName path string true "Device Group Name"
// @Accept       json
// @Produce      json
// @Router       /config/v1/device-group/{deviceGroupName} [get]
func GetDeviceGroupByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Device Group by name")

	var deviceGroup configmodels.DeviceGroups
	filter := bson.M{"group-name": c.Param("group-name")}
	rawDeviceGroup, errGetOne := dbadapter.CommonDBClient.RestfulAPIGetOne(devGroupDataColl, filter)
	if errGetOne != nil {
		logger.DbLog.Warnln(errGetOne)
	}
	json.Unmarshal(mapToByte(rawDeviceGroup), &deviceGroup)

	if deviceGroup.DeviceGroupName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, deviceGroup)
	}
}

// @Summary Delete an existing device group
// @Tags Device Groups
// @Description Delete an existing Device Group
// @Param deviceGroupName path string true "Device Group Name"
// @Success 202 {string} string "Device Group deleted successfully"
// @Failure 400 {string} string "Invalid Device Groups name provided"
// @Failure 500 {string} string "Error deleting Device Group"
// @Router /config/v1/device-group/{deviceGroupName} [delete]
func DeviceGroupGroupNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNameDelete")
	if ret := DeviceGroupDeleteHandler(c); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// DeviceGroupGroupNamePut -
func DeviceGroupGroupNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePut")
	if ret := DeviceGroupPostHandler(c, configmodels.Put_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// DeviceGroupGroupNamePatch -
func DeviceGroupGroupNamePatch(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePatch")
	c.JSON(http.StatusOK, gin.H{})
}

// @Summary Create a new Device Group
// @Tags Device Groups
// @Description Create a new Device Group
// @Param deviceGroupName path string true "Device Group Name"
// @Success 200 {string} string "Device Group created"
// @Failure 400 {string} string "Invalid Device Group content"
// @Failure 500 {string} string "Error creating Device Group"
// @Router /config/v1/device-group/{deviceGroupName} [post]
func DeviceGroupGroupNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePost")
	if ret := DeviceGroupPostHandler(c, configmodels.Post_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// GetNetworkSlices godoc
// @Summary      Show an account
// @Description  Returns the list of network slices
// @Tags         Network Slices
// @Accept       json
// @Produce      json
// @Router       /config/v1/network-slice/ [get]
func GetNetworkSlices(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Network Slices")

	var networkSlices []string = make([]string, 0)
	rawNetworkSlices, errGetMany := dbadapter.CommonDBClient.RestfulAPIGetMany(sliceDataColl, bson.M{})
	if errGetMany != nil {
		logger.DbLog.Warnln(errGetMany)
	}
	for _, rawNetworkSlice := range rawNetworkSlices {
		networkSlices = append(networkSlices, rawNetworkSlice["SliceName"].(string))
	}

	c.JSON(http.StatusOK, networkSlices)
}

// GetNetworkSlice godoc
// @Summary      Show an account
// @Description  Returns the network slice
// @Tags         Network Slices
//  @Param       sliceName path string true "Slice Name"
// @Accept       json
// @Produce      json
// @Router       /config/v1/network-slice/{sliceName} [get]
func GetNetworkSliceByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Network Slice by name")

	var networkSlice configmodels.Slice
	filter := bson.M{"SliceName": c.Param("slice-name")}
	rawNetworkSlice, errGetOne := dbadapter.CommonDBClient.RestfulAPIGetOne(sliceDataColl, filter)
	if errGetOne != nil {
		logger.DbLog.Warnln(errGetOne)
	}
	json.Unmarshal(mapToByte(rawNetworkSlice), &networkSlice)

	if networkSlice.SliceName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, networkSlice)
	}
}

// @Summary Delete an existing network slice
// @Tags Network Slices
// @Description Delete an existing network slice
// @Param sliceName path string true "Slice Name"
// @Success 202 {string} string "Network slice deleted successfully"
// @Failure 400 {string} string "Invalid network slice name provided"
// @Failure 500 {string} string "Error deleting network slice"
// @Router /config/v1/network-slice/{sliceName} [delete]
func NetworkSliceSliceNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNameDelete ")
	if ret := NetworkSliceDeleteHandler(c); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// @Summary Create a new network slice
// @Tags Network Slices
// @Description Create a new network slice
// @Param sliceName path string true "Slice Name"
// @Success 200 {string} string "Network slice created"
// @Failure 400 {string} string "Invalid network slice content"
// @Failure 500 {string} string "Error creating network slice"
// @Router /config/v1/network-slice/{sliceName} [post]
func NetworkSliceSliceNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePost ")
	if ret := NetworkSlicePostHandler(c, configmodels.Post_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// NetworkSliceSliceNamePut -
func NetworkSliceSliceNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePut ")
	if ret := NetworkSlicePostHandler(c, configmodels.Put_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}
